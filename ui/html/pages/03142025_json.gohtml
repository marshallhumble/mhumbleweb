{{define "main"}}

    <h1>Shift Left: Why Security Should Start Early in Development</h1>

    <h2>Introduction</h2>
    <p>Traditional security practices often come too late in the Software Development Life Cycle (SDLC), leading to
        vulnerabilities that are costly and time-consuming to fix. Shifting security left means integrating security
        practices early in the development process, reducing risk and minimizing technical debt.</p>

    <h2>Why Traditional Security Approaches Fail</h2>
    <ul>
        <li><strong>Security as an Afterthought:</strong> Testing security only in QA or post-production leads to costly fixes.</li>
        <li><strong>Increased Cost of Fixing Late-Stage Issues:</strong> A vulnerability found in production is significantly more expensive to remediate.</li>
        <li><strong>Lack of Developer Awareness:</strong> Without security training, developers unintentionally introduce vulnerabilities.</li>
        <li><strong>Compliance and Audit Pressures:</strong> Security fixes at the last minute create delays and inefficiencies.</li>
    </ul>

    <p>The <a href="https://www.researchgate.net/figure/BM-System-Science-Institute-Relative-Cost-of-Fixing-Defects_fig1_255965523">
            Systems Science Institute at IBM</a> and <a href="https://www.nist.gov/system/files/documents/director/planning/report02-3.pdf">
    NIST's</a> reports agree that finding bugs earlier in development can lead to massive cost and time reduction.
    It can cost 6 times as much to fix a bug in during implementation than to fix one identified during design.
    The cost to fix bugs found during the testing phase can be 15x more than those found during design.</p>


    <h2>Benefits of Shifting Security Left</h2>
    <ul>
        <li><strong>Faster and Cheaper Remediation</strong></li>
        <li><strong>Better Developer Security Awareness</strong></li>
        <li><strong>Reduced Risk of Data Breaches</strong></li>
        <li><strong>Lower Technical Debt</strong></li>
        <li><strong>Stronger DevSecOps Culture</strong></li>
    </ul>

    <h2>How to Shift Security Left: Practical Steps</h2>

    <h3>1. Develop a culture of security</h3>
        <br>
        <p>The first, and often overlooked thing is to as we shift left, is to shift mindsets. Often development
            teams only consider security and QA teams to be an annoyance rather than a benefit. The focus is only on
            getting an MVP out the door. Anything in the way of that is seen as either something to be handled later
            or in some cases derided as a negative.</p>
        <br>
        <p>In order to change that mindset it is imperative to produce of culture of security. This means a focus on
        secure practices and also manager/leader buy in from the start. If the leads tell the new team members to just
        "click through this mandatory training" it is clear that they don't care about it, so neither should the new
        dev on the team. Buy-in from across the organization is critical.</p>
    <br>

    <ul>
        <li>Encourage a culture of security through the organization</li>
        <li>Require <strong>code reviews with security checks</strong>.</li>
        <li>Encourage <strong>threat modeling</strong> during the design phase.</li>
    </ul>
        <br>
        <p>Some resources here can be found on OWASP for example the
            <a href="https://owasp.org/www-project-developer-guide/">OWASP Developer Guide</a> and the
            <a href="https://owasp.org/www-project-threat-model/">OWASP Threat Modeling Guide</a> and
            <a href="https://www.youtube.com/watch?v=fb-t3WWHsMQ">OWASP DevSlop on YouTube's guide to Code Review the
                Offensive Security Way</a> are all some resources that can be used, among others.</p>
        <br>
        <br>

    <h3>2. Automate Security in CI/CD Pipelines</h3>
    <ul>
        <li>Use tools inside the IDE, linting (readable code is more secure!) and securing coding plugins</li>
        <li>Use <strong>SAST</strong> (Static Application Security Testing) tools to scan code before merging.</li>
        <li>Integrate <strong>DAST</strong> (Dynamic Application Security Testing) for running applications.</li>
        <li>Use <strong>SCA</strong> (Software Composition Analysis) tools to check code quality and asses vulnerabilities</li>
        <li>Automate <strong>dependency checks</strong> for third-party libraries.</li>
    </ul>
        <br>
        <p>Some examples of tools above are:</p>
    <ul>
        <li>Linters: ESLint (JS/TS), JSHint (JS), Prettier (JS/TS), Go fmt (Go lang), Black (Python),
        Pylint (Python), etc.</li>
        <li>Secure Code Plugins: Secure code plugins (most of these work with multiple languages) like SonarQube,
           Checkmarx, or Semgrep, ESLint (eslint-plugin-security) Synk, NodeJSScan (JS [Node]), Bandit (Python),
           GoSec (Go), Staticcheck (Go), Goline and Govet (Go) can also be used for code "Smells".</li>
        <li>DAST: OWASP ZAP (Zed Attack Proxy) works on multiple languages, and can be automated into the CI/CD pipeline,
        Arachni (JS), Netsparker (React, Angular, Vue), Wapiti (Python), Gauntlt (Go) integrated into other tools like
             ZAP, Nikto, and SQLMap, Tsunmai, Nikto and Burp Suite (multiple languages, scanners/manual testing tools)</li>
        <li>SCA: Snyk, OWASP Dependency-Check, Dependabot (Multiple languages, can be automated into CI/CD), npm audit (JS),
            Retire.js (JS), Pip-audit (Python), Safety (Python), GoSec (Go), Go Audit (Go)</li>
    </ul>
        <br>
        <br>

    <h3>3. Enforce Secure Dependencies Management</h3>
    <ul>
        <li>Use tools like <strong>Snyk, OWASP Dependency-Check</strong>, and <strong>GitHub Dependabot</strong> to scan for vulnerabilities.</li>
        <li>Set up <strong>automated alerts</strong> for dependency vulnerabilities.</li>
        <li>Maintain a <strong>SBOM</strong> (Software Bill of Materials) for supply chain security.</li>
    </ul>
        <br>
        <p>Many of the dependency management tools were listed above so I won't duplicate that work, but I will add
            in SCOM tools.</p>
        <ul>
            <li>Syft (multiple languages, works with Docker) OWASP Dependency-Track (multiple),
                CycloneDX CLI (JS [npm, yarn, pnpm]), CycloneDX Python, Pip-audit (Python), bom (Go), Go-List/Go-Audit (Go) </li>
        </ul>

    <h3>4. Implement Security Testing Early and Continuously</h3>
    <ul>
        <li>Conduct <strong>security unit tests</strong> alongside functional tests.</li>
        <li>Use <strong>fuzz testing</strong> to identify unexpected vulnerabilities.</li>
        <li>Run <strong>container security scanning</strong> if using Docker/Kubernetes.</li>
    </ul>
        <p>Here I will list out some fuzzing tools:</p>
        <ul>
            <li>Jazzer.js (JS), Fuzzilli (JS), Node-Fuzz (JS), Ahteris (Python), FuzzyWuzzy (Python), Radamsa (Python),
            Go native fuzzing library that works alongside Go test packages, Go-Fuzz (Go), gfuzz (Go)</li>
        </ul>

    <h3>5. Use Infrastructure as Code (IaC) Security Checks</h3>
    <ul>
        <li>Use <strong>Terraform, Ansible, or CloudFormation</strong> security scanning tools.</li>
        <li>Prevent misconfigurations by scanning <strong>IaC templates</strong> before deployment.</li>
    </ul>
        <br>
        <p>Here are tools for checking IaC:</p>
        <ul>
            <li>Checkov: Scans Terraform, Kubernetes, CloudFormation, and Docker files for security misconfigurations.
                Supports AWS, Azure, and Google Cloud security policies. This can be used in the CI/CD pipeline</li>
            <li>TFSec: Terraform, looks for hardcoded secrets, insecure IAM policies, and misconfigurations.</li>
            <li>KubeLinter: Kubernetes YAML, Helm charts, and Kustomize files for security risks.
                Identifies privilege escalation risks, insecure container configurations, and network issues.</li>
            <li>kube-bench: Checks Kubernetes clusters against CIS Benchmarks.
                Detects RBAC misconfigurations, API server exposure, and pod security issues.</li>
            <li>cfn-link: Checks AWS CloudFormation templates against security best practices.</li>
            <li>CFN-Nag: Used for AWS CloudFormation configurations. Identifies publicly exposed S3 buckets,
                overly permissive IAM roles, and hardcoded credentials.</li>
            <li>Trivy: Docker, Kubernetes and looks for vulnerabilities in containerized applications</li>
            <li>Docker Bench for Security: Evaluates Docker Daemon security settings based on CIS Benchmarks.</li>
            <li>Docker Desktop can also be used to view image details and CVEs, and issues with containers</li>
        </ul>

    <h3>6. Train Developers in Security Awareness</h3>
    <ul>
        <li>Provide <strong>regular security training</strong> and simulated attack exercises.</li>
        <li>Encourage developers to <strong>participate in bug bounty programs</strong>.</li>
        <li>Use <strong>capture-the-flag (CTF) challenges</strong> to make security training interactive.</li>
    </ul>
        <br>
    <p>Training should also be more than just an annual click through, ideas should be integrated into talks and
        standups through the year. Organizations can also encourage devs to participate in Capture the Flag (CTF)
        events or bug bounty programs in the organization and outside. Other areas for growth and training are
        Hack the Box and Vulnhub for "hands on" examples.</p>
        <br>
    <p>Shifting security left <strong>reduces risk, lowers costs, and strengthens security posture</strong>.
        By <strong>integrating security in development, automating checks, and training developers</strong>,
        organizations can build secure software from the ground up.</p>

{{end}}