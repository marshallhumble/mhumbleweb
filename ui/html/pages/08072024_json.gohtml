{{define "main"}}

	<h1>Using JSON in Go</h1>
	<p>
		I'm always consistently impressed by how Go works. From <i>actually</i> being secure by default to handling minor tasks efficiently,
		Go always seems to be designed in a logical way that lets you just get the work done.
	</p>
	<p>
		Similarly, JSON in Go is fairly simple and uses the <code>encoding/json</code> module, which is Go’s implementation
		of the <a href="https://datatracker.ietf.org/doc/html/rfc8259">RFC 8259</a> JSON Standard. JSON is widely used on the web, commonly in APIs or to send data
		to a frontend server running JavaScript.
	</p>
	<p>
		In Go, encoding JSON is referred to as marshaling (serializing), and decoding is called unmarshaling (deserializing).
		As expected in Go, this is straightforward. You simply define a struct that represents the JSON <i>data structure</i>.
		Field names must match exactly.
	</p>
	<pre>
    <code class="language-go line-numbers" data-prismjs-copy="Copy Me!">
package main

import (
	"encoding/json"
	"fmt"
	"log"
)

func main() {
	type Team struct {
		Name string `json:"Name"`
		City string `json:"City"`
	}

	teams := []Team{
		{"Spurs", "San Antonio"},
		{"Mavericks", "Dallas"},
		{"Rockets", "Houston"},
	}

	b, err := json.Marshal(teams)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(string(b))
}
    </code>
	</pre>
	<p>Which will return:</p>
	<pre>
		<code class="language-json" data-prismjs-copy="Copy Me!">
[{"Name":"Spurs","City":"San Antonio"},{"Name":"Mavericks","City":"Dallas"},{"Name":"Rockets","City":"Houston"}]
		</code>
	</pre>
	<p>
		You can also replace <code>fmt.Println(string(b))</code> with the following to get nicely formatted JSON:
	</p>
	<pre>
	<code class="language-go">
var out bytes.Buffer
json.Indent(&out, b, "", "\t")
out.WriteTo(os.Stdout)
	</code>
</pre>
	<p>This returns:</p>
	<pre>
	<code class="language-json">
[
	{
		"Name": "Spurs",
		"City": "San Antonio"
	},
	{
		"Name": "Mavericks",
		"City": "Dallas"
	},
	{
		"Name": "Rockets",
		"City": "Houston"
	}
]
	</code>
</pre>
	<p>
		For a slightly more complex example, let's add the wins and losses for each team during the 2023-2024 season.
		We will nest the scores in the existing JSON structure like so:
	</p>
	<pre>
	<code class="language-json">
[
	{
		"Name": "Spurs",
		"City": "San Antonio",
		"Scores": {
			"Wins": 22,
			"Losses": 60
		}
	}
]
	</code>
	</pre>
	<p>To achieve this, we need to define an additional struct:</p>
	<pre>
	<code class="language-go">
type (
	Team struct {
		Name   string `json:"Name"`
		City   string `json:"City"`
		Scores Scores `json:"Scores"`
	}
	Scores struct {
		Wins  int `json:"Wins"`
		Losses int `json:"Losses"`
	}
)
	</code>
</pre>
	<p>
		Which we can then use in our Go program:
	</p>
	<pre>
	<code class="language-go">
func main() {
	team := Team{
		Name: "Spurs",
		City: "San Antonio",
		Scores: Scores{
			Wins: 22,
			Losses: 60,
		},
	}

	b, err := json.Marshal(team)
	if err != nil {
		log.Fatalf("Unable to marshal due to %s\n", err)
	}

	fmt.Println(string(b))
}
	</code>
</pre>
	<p>Which produces:</p>
	<pre>
	<code class="language-json">
{
	"Name": "Spurs",
	"City": "San Antonio",
	"Scores": {
		"Wins": 22,
		"Losses": 60
	}
}
	</code>
</pre>
	<p>
		Go also allows for an HTML-escaped version of JSON output, making it safe to embed inside script tags.
		The following example from the Go documentation demonstrates this:
	</p>
	<pre>
	<code class="language-go">
package main

import (
	"bytes"
	"encoding/json"
	"os"
)

func main() {
	var out bytes.Buffer
	json.HTMLEscape(&out, []byte(`{"Name":"<b>HTML content</b>"}`))
	out.WriteTo(os.Stdout)
}
	</code>
</pre>
	<p>Which returns:</p>
	<pre>
	<code class="language-json">
{"Name":"\u003cb\u003eHTML content\u003c/b\u003e"}
	</code>
</pre>
	<p>
		Understanding JSON in Go is essential for working with APIs and structured data. The language’s encoding/json package makes
		it simple to serialize and deserialize JSON efficiently. Happy coding!
	</p>

{{end}}