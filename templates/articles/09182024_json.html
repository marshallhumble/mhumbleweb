
    <h1>Google's SafeOpen for Go</h1>
    <br>
    <p>
        The Google <a href="https://pkg.go.dev/github.com/google/safeopen">SafeOpen package</a> provides an extra level
        of security when handling file uploads from the web.</p>
        <br>
    <p>If the Go proposal for <a href="https://github.com/golang/go/issues/67002#issuecomment-2243459398">safer open
            file functions</a> is accepted, then the SafeOpen package may become redundant. However, as of now, it is a
        useful tool for enhancing file security.</p>
        <br>
    <p>SafeOpen replaces the <code>os.*</code> functions for file creation and opening, ensuring that files can only be
        created or opened in a designated directory. This prevents <a href="https://owasp.org/www-community/attacks/Path_Traversal">
            directory/path traversal attacks</a>, restricting access to unauthorized locations like
        <code>../../../../etc/passwd</code>.</p>
        <br>
    <p>Below are two examples demonstrating SafeOpen usage in Goâ€™s standard <code>net/http</code> library, focusing
        only on the file upload portion of the server function.
    </p>
    <br><br>
    <h2>Single File Example</h2>
    <br>
    <pre>
        <code class="language-go line-numbers">
        // Retrieve the file from the form
        file, fHeader, err := r.FormFile("uploadFile")
        if err != nil {
            app.logger.Error("Handler Error: ", err.Error(), "error")
            // Handle the error appropriately
            app.render(w, r, http.StatusUnsupportedMediaType, "home.html", data)
        }
        defer file.Close() // Ensure the file is closed

        // Check for a valid upload
        if fHeader.Size > 0 {
            // Use SafeOpen's CreateAt instead of os.Create
            f, err := safeopen.CreateAt("./uploads/", fHeader.Filename)
            if err != nil {
                return
            }
            defer f.Close()

            // Copy file contents to the destination
            _, err = io.Copy(f, file)
            if err != nil {
                return
            }
        }
        </code>
    </pre>
    <br>
    <p>For the full example, see my implementation on <a href="https://github.com/marshallhumble/WebFileShare/blob/main/cmd/web/handlersFiles.go">GitHub</a> in WebFileShare.</p>
    <br>
    <h2>Multi-File Example</h2>
    <br>
    <pre>
    <code class="language-go">
    multipartFormData := r.MultipartForm

    for key, file := range multipartFormData.File["uploadFile"] {

        // Limit uploads to 5 files
        if key < 5 {

            // Rename the uploaded file
            ext := filepath.Ext(file.Filename)
            nTime := fileDate(time.Now()) // Format timestamp
            id := app.sessionManager.GetInt(r.Context(), "authenticatedUserID")

            // Generate a sanitized filename
            file.Filename = strings.ReplaceAll(strconv.Itoa(id)+strings.ToLower(strings.TrimSuffix(file.Filename,
                filepath.Ext(file.Filename))), " ", "-") + "-" + fmt.Sprintf("%v", nTime) + ext

            // Use SafeOpen to securely create the file
            dst, err := safeopen.CreateAt("./ui/static/pics", file.Filename)
            if err != nil {
                app.clientError(w, http.StatusBadRequest)
                return
            }

            // Copy the file contents
            f, _ := file.Open()
            io.Copy(dst, f)

            // Store file names into separate fields in the database
            switch key {
            case 0:
                form.Item1 = file.Filename
            case 1:
                form.Item2 = file.Filename
            case 2:
                form.Item3 = file.Filename
            case 3:
                form.Item4 = file.Filename
            case 4:
                form.Item5 = file.Filename
            default:
                form.Item1 = file.Filename
            }
        }
    }
    </code>
    </pre>
    <br>
